[{"contents":"","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/algorithm/","section":"series","summary":"","tags":null,"title":"Algorithm"},{"contents":"","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/java/","section":"series","summary":"","tags":null,"title":"Java"},{"contents":"","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/","section":"series","summary":"","tags":null,"title":"编程概念"},{"contents":"","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/golang/","section":"series","summary":"","tags":null,"title":"Golang"},{"contents":"","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/","section":"series","summary":"","tags":null,"title":"Series"},{"contents":" 如何自动对对象进行 json 序列化 前情提要 java 开发中，大家一般都会用 Slf4j+logback 的组合来写日志。我也是。\nlogback 有个很方便的功能：当你占位符对应的参数是个对象的时候，它会自动调用该对象的 toString 方法进行序列化，不用你手动做调用。\n这个已经挺方便了，但是这样子的数据展示方式还是有局限性。当你需要把一段数据拿出来给其他语言的后端、前端，甚至是业务和运营看的时候，一段 raw 的数据，对方很可能就拒绝了。\n这个时候我就想到，json 是一种更通用的数据格式啊。java 里本身就有很多方便快捷的 json 框架直接使用，而且就算你拿出来的还是一行数据，现在网上有那么多 json 美化工具，查看的门槛其实很低的。\n方案设计 确定了需要转换的格式之后，就是确定实现细节了。刚开始其实我想的是写个切面，但是很快就意识到这样并不优雅。\n为了操作到所有的日志，你肯定需要把切点织入 logback 的相关方法。简单来说，就是 ch.qos.logback.classic.Logger 这个类的方法中。那么多方法重载，看着都心累。。。\n当然，用切面肯定能实现自动 json 序列化，但是我想做的其实是「替换掉日志输出中的序列化一环」，而不是「在写日志前加一个统一操作」。两者的含义并不一样，前者是对日志框架的修改，后者是对项目本身的修改。\n所幸，后来被我找到了 logback 本身的 hook-转换器，可以在内部进行 json 方法的调用。\n具体实现 网上找到一篇自定义 MessageConverter 的文章：自定义一个 logback 的 MessageConverter。\n原文用的是 fastjson。虽然公司大量用的都是这个 json 框架，但我自己的项目为了减少依赖，会直接使用 spring-boot-starter-web 里的 jackson。下面贴出我的修改版：\n自定义一个 converter： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class JsonConverter extends MessageConverter { private final static ObjectMapper OBJECT_MAPPER = new ObjectMapper(); @Override public String convert(ILoggingEvent event) { try { List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (Object argument : event.getArgumentArray()) { Object o = (argument.getClass().getClassLoader() != null || argument instanceof Collection || argument instanceof Map) ? OBJECT_MAPPER.writeValueAsString(argument) : argument; list.add(o); } return MessageFormatter.arrayFormat(event.getMessage(), list.toArray()).getMessage(); } catch (Exception e) { return super.convert(event); } } } 添加自定义 converter 到 logback-spring.xml 配置文件中 1 2 3 \u0026lt;configuration\u0026gt; \u0026lt;conversionRule conversionWord=\u0026#34;msg\u0026#34; converterClass=\u0026#34;xxx.xxx.xxx.config.JsonConverter\u0026#34;/\u0026gt; \u0026lt;/configuration\u0026gt; logback 转换器原理分析 虽然这样可以自动序列化了，但我还是有不少疑问：\nMessageConverter 已经是一个具体的类了，为什么要继承它而不是它的父类 ClassicConverter 呢？为什么只要在配置文件里添加 conversionRule 就能被 logback 使用呢？如果对一个关键字添加了多个转换器，它们是怎么被调用的呢？\n这些答案，都只能靠看源码了。\nspringboot 加载 logback 配置文件 springboot 是使用 LoggingApplicationListener 这个类完成对日志系统初始化的。我们先来看下这个类，顺便还能理解怎么自动装配的 logback-spring.xml 文件。\n当然，先放张时序图便于理解：\n首先，LoggingApplicationListerner使用观察者模式监听到 spring 应用启动后的环境准备事件：ApplicationEnvironmentPreparedEvent，然后就会去执行相关的初始化操作，获取配置文件。\n获取配置文件的步骤就是 spring 的特殊化处理。它会先在getSelfInitializationConfig查找 logback 的标准配置文件：\u0026ldquo;logback-test.groovy\u0026rdquo;, \u0026ldquo;logback-test.xml\u0026rdquo;, \u0026ldquo;logback.groovy\u0026rdquo;, “logback.xml\u0026quot;。如果这些文件都没有找到，spring 会去做一个文件名的修改，再去获取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Return the spring config locations for this system. By default this method returns * a set of locations based on {@link #getStandardConfigLocations()}. * @return the spring config locations * @see #getSpringInitializationConfig() */ protected String[] getSpringConfigLocations() { String[] locations = getStandardConfigLocations(); for (int i = 0; i \u0026lt; locations.length; i++) { String extension = StringUtils.getFilenameExtension(locations[i]); locations[i] = locations[i].substring(0, locations[i].length() - extension.length() - 1) + \u0026#34;-spring.\u0026#34; + extension; } return locations; } 它会把字符串拆成两部分，.前的部分，和.后的部分（extension），然后在两者之间加上-spring.组成新的字符串。logback.xml -\u0026gt; logback-spring.xml。\n这就是为什么说没有 logback.xml 文件的时候 spring 会自动去找 logback-spring.xml 文件的原因，也是为什么存在了 logback.xml 后 logback-spring.xml 配置就会失效。\nlogback 完成配置初始化 loadConfiguration方法会在完成前置动作后，把相关信息交还给 logback，logback 会使用 JoranConfigurator 进行配置初始化。\n来，再来个时序图(只会提供转换器相关初始化的过程，其他元素的动作被省略了）：\n细节上，SaxEventRecorder 在进行 recordEvents 时会创建一个 SAXParser 用于解析 xml 文件，然后再调用重载的 startElement 方法把相关的 startElement 放到一个 list 中。 startElement 方法中，先过滤出相关 tag 的 action，然后调用 callBeginAction 依次执行具体 action 的 begin 方法。在我们这儿，就是 ConversionRuleAction。\n在 ConversionRuleAction 中，会提取 conversionWord 和 conversionClass，然后把这两个字段作为一对 KV，插入一个叫 ruleResigtry 的 hashMap 中。而 ruleResigtry 本身，则会被保存在 logback 全局的 context 中。 再加之后的一些验证、上下文信息补全的操作，logback 就把一个配置文件的内容反序列化到上下文中了。\ntip这里也能看出一个结论，当你对同一个 conversionWord 提供了多个不同的转换器的时候，只有最后一个会生效。因为依次对 conversionRule 执行ConversionRuleAction#begin，新的一个转换器会覆盖掉 ruleRegistry 中相同 key 的值。（hashMap#put 的基本知识） Logger 的具体调用 最后在实际使用上的流程：\n而 PatternLayout 继承的 PatternLayoutBase 会在自身初始化的时候，解析配置文件中的正则表达式，然后将关键字对应的转换器添加到一条链表中。所以在执行 writeLoopOnConverters 的时候，就是依次执行这些转换器，最后吐出一条转换完的字符串。（具体初始化的调用在哪还没看到，之后看完了再重新写一篇吧）\n总结 如果你只是需要添加 json 序列化的话，不用继承 MessageConverter，直接继承 ClassicConverter 然后提供相关的自定义配置就可以了。当然别忘了再配置文件里加上 conversionRule。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class JsonConverter extends ClassicConverter { private final static ObjectMapper OBJECT_MAPPER = new ObjectMapper(); @Override public String convert(ILoggingEvent event) { try { List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (Object argument : event.getArgumentArray()) { Object o = (argument.getClass().getClassLoader() != null || argument instanceof Collection || argument instanceof Map) ? OBJECT_MAPPER.writeValueAsString(argument) : argument; list.add(o); } return MessageFormatter.arrayFormat(event.getMessage(), list.toArray()).getMessage(); } catch (Exception e) { return event.getFormattedMessage(); } } } ","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/java/logback-%E8%87%AA%E5%8A%A8-json-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","section":"series","summary":"如何自动对对象进行 json 序列化 前情提要 java 开发中，大家一般都会用 Slf4j+logback 的组合来写日志。我也是。 logback 有个很方便的功能：当你占位符对应的参数是个对象的时候，","tags":["logback","converter"],"title":"Logback 自动 Json 序列化和转换器原理解析"},{"contents":"昨天在 Leetcode 中国上看到两数之和的官方解法评论里，有人认为暴力法应该比哈希表更快。想就此讨论下。\n首先，暴力法的时间复杂度是 $O(n^2)$，这个大家都认可。那么使用哈希表的时间复杂度到底是多少呢？查找的时候，索引直接使用哈希值计算得出，所以大部分情况为 $O(1)$。但是还要考虑到插入时的哈希冲突。\n对于哈希表，Java 在插入的时候为了避免大量冲突，会进行自动扩容，即源码中的 resize 方法。简单来说，当元素数达到容量的 75% 时（默认，可修改），自动扩容为原来的两倍。同时，对已存储的元素重新记算桶下标。\n具体源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 if (oldTab != null) { for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; do { next = e.next; if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } 所以展开后，是 for 循环下套一个 for 循环。这也是不少人认为哈希表的时间复杂度为 \u0010$O(n^2)$ 的原因。但是，不要忘记每次扩容的大小为原来的两倍，而一个哈希表的默认初始容量为 16。\n精密地说，暴力法的循环次数为 $\\sum_{i=1}^n i$，使用等差数列求和公式得到和为 $\\frac{(1+n)n}{2} = \\frac{n^2+n}{2}$。去除杂项后才得到了 $O(n^2)$ 的复杂度。\n而哈希表扩容时，是一个比值为 2 等比数列，为了方便计算，我们可以把首项设为 1（$2^0$）。这里面的重点是：对于相同的 n，哈希表扩容次数为 $\\log_2(n)+1$，而不是 n。理由很简单，初始为 1，每次 $\\times 2$，当经历了 $\\log_2(n)+1$ 次扩容后，实际容量就为 $2n$ 了，存储量永远不会超过容量的 75%，就没必要继续扩容了。\n因此，使用哈希表的总循环次数为 ${\\sum_{i=0}^{\\log_2(n)+1} 2^i}+k (k={n-{\\log_2(n)-1}})$（其中 k 指不进行扩容的插入次数）。使用等比数列求和公式得到和为 $\\frac{1(1-2^{\\log_2(n)+1})}{1-2}+k = 2n-1+k$。去除杂项之后得到的时间复杂度为 $O(n)$。\n总结 结论很简单，那就是使用哈希表的时间复杂度确实是 $O(n)$，但问题不是在 ContainsKey 方法大部分时间都可以直接命中，而是第一次插入时的扩容上。\n这给我们的提示是：时间复杂度的估计不能只是看它出现了几个 for、while 循环，而要真正地考虑、记算它的循环次数。这也是为什么说算法的时候很多人还是会建议多一些数学思维。\n","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/algorithm/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E6%AF%94%E6%9A%B4%E5%8A%9B%E6%B3%95%E5%BF%AB/","section":"series","summary":"\u003cp\u003e昨天在 Leetcode 中国上看到两数之和的\u003ca href=\"https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\" target=\"_blank\" rel=\"external\"\u003e官方解法评论\u003c/a\u003e里，有人认为暴力法应该比哈希表更快。想就此讨论下。\u003c/p\u003e","tags":["哈希表","时间复杂度"],"title":"为什么求两数之和用哈希表比暴力法快"},{"contents":" 假设有一个长度为 n 的数组，所有数字都在 0~n-1 范围内。数组中某些数字是重复的，但不知道几个数字重复了，也不知道每个数字重复了几次。\n请找出数组中任意一个重复的数字。\n例如：一个数组 array: {2, 3, 1, 2, 4, 5}，那么对应输出是重复数字 2\n事实上，使用 HashMap 之类的辅助备忘来完成是很普通且常见的方式。但是如果需要原地，也就是空间复杂度也为 $O(1)$ 则需要一定的技巧。\n首先，极端情况，当数组中 所有数都不重复 时，数组拥有的数字就是所有 0~n-1 个不同的数字。那么进行排序之后可以得到 数字和所在下标一致 的结论。\n那么有重复数字就意味着两个或两个以上的下标上的数字是相同的。\n那么结论就出来了，我们可以在排序的同时判断重复。\n但是实际上我们不需要使用一个通用的排序算法。我们已经证明了所有下标和数字对应的时候是有序的，那我们实际只需要把数字交换到对应下标上就完成了排序。\n具体过程就是：\n从下标 0 对应的数字开始，首先查看它所对应的下标 array[0] 上的数字是否和它重复。若重复则直接可返回；若不重复，则将 array[0] 和 array[array[0]] 交换位置 此时若 array[0] != 0，则继续进行同上交换；若 array[0] == 0，则移动到下一个下标，即 1，然后仍然对 array[1] 做同上交换 如此反复 这里给出一份代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public static int duplicationNum(int[] nums) { int i = 0; do { if (nums[i] == nums[nums[i]]) {// 若当前值和以当前值为索引的值相同，找到重复，返回 return nums[i]; } else {// 否则，交换并在索引和所在位置上的数相同时向后一位继续 swap(i, nums[i], nums); if (i == nums[i]) { ++i; } } } while (i \u0026lt; nums.length); return nums.length;// 当不存在重复时，返回数组的长度（其实返回任何一个大于等于数组长度的数都没问题） } private static void swap(int from, int to, int[] array) { int tmp = array[from]; array[from] = array[to]; array[to] = tmp; System.out.println(Arrays.toString(array));// 输出每次交换后的数组 } } 当然，你也可以用通用排序后查找重复的方式，基本就是两个指针顺序后移查看是否相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static int duplicationNum2(int[] nums) { Arrays.sort(nums); int slow = 0, fast = 1; do { if (nums[slow] == nums[fast]) { return nums[slow]; } ++slow; ++fast; } while (fast \u0026lt;= nums.length); return nums.length; } 顺便说一句， Arrays.sort 底层使用的是快排、双轴快排、归并排序、插入排序和计数排序等，时间复杂度随着数组长度不同在 $O(n)$~$O(n\\log{}n)$ 之间。\n","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/algorithm/%E6%95%B0%E7%BB%84%E5%86%85%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-o1/","section":"series","summary":"\u003cblockquote\u003e\n\u003cp\u003e假设有一个长度为 n 的数组，所有数字都在 0~n-1 范围内。数组中某些数字是重复的，但不知道几个数字重复了，也不知道每个数字重复了几次。\u003cbr /\u003e\n请找出数组中任意一个重复的数字。\u003cbr /\u003e\n例如：一个数组 array: {2, 3, 1, 2, 4, 5}，那么对应输出是重复数字 2\u003c/p\u003e\n\u003c/blockquote\u003e","tags":null,"title":"数组内查询重复(空间复杂度 O(1))"},{"contents":"Lombok 是 Java 开发的一件利器，它可以减少大量模板代码的使用。在其中最常使用到的注解应该就是 @Data ，可以在编译时自动生成 getter、setter、\nequals、hashcode 等方法。而 @Builder 则用来快速实现 builder 模式。但是，如果两者同时使用却会产生一些意想不到的报错。\n如果单纯在 class 上添加这两个注解，IDE 会提示缺少无参构造器。\n在此基础上添加 @NoArgsConstructor 注解后则会直接报错。\n然后你会在使用谷歌或者百度之后学会再加一个 @AllArgsConstructor 注解，发现问题解决了。\n首先，为什么在 @Data 的基础上添加 @Builder 会出现缺少无参构造器的问题 这个其实比较好理解。无参构造器就是 class 的默认构造器，如果你没有显式声明它，那么在编译时，编译器发现你没有显式声明的构造器，就会自动生成一个无参构造器。\n而添加了 @Builder 后，Lombok 为我们添加了一个全参构造器，编译器找到了显式声明的构造器，却没有显式声明的无参构造器，则会编译失败。\n然后，添加无参构造器后方法参数问题 手动声明无参构造器之后，@Builder 注解会调用另一段逻辑：\n简单来说，如果源码中没有声明构造器，则自动生成全参构造器；若你已经声明了一个构造器，那么它就放弃生成。\n但是 builder 模式的最后一个动作，build，还是默认调用全参的构造器来生成对象。这才造成了 期望是个无参构造器，获得的参数列表却不一样 的报错。\n总结 当你希望同时使用 @Data 和 @Builder 注解时，记住需要自己显式声明 无参构造器 和 全参构造器。这可以通过添加 @NoArgsConstructor 和 @AllArgsConstructor 注解实现。\n当然，你也可以不用注解，自己写代码。IDEA 可以快速创建构造器。\n","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/java/lombok-%E4%B8%AD-data-%E5%92%8C-builder-%E5%90%88%E7%94%A8%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/","section":"series","summary":"\u003cp\u003eLombok 是 Java 开发的一件利器，它可以减少大量模板代码的使用。在其中最常使用到的注解应该就是 \u003ccode\u003e@Data\u003c/code\u003e ，可以在编译时自动生成 \u003ccode\u003egetter\u003c/code\u003e、\u003ccode\u003esetter\u003c/code\u003e、\u003cbr /\u003e\n\u003ccode\u003eequals\u003c/code\u003e、\u003ccode\u003ehashcode\u003c/code\u003e 等方法。而 \u003ccode\u003e@Builder\u003c/code\u003e 则用来快速实现 builder 模式。但是，如果两者同时使用却会产生一些意想不到的报错。\u003c/p\u003e","tags":["lombok"],"title":"Lombok 中 Data 和 Builder 合用产生的问题"},{"contents":" 说明 同步：必须等到资源返回之后才能继续执行 异步：先请求资源，之后在需要的地方使用资源 阻塞：资源请求后，必须成功获取返回后才能继续执行 非阻塞：先请求资源，之后在使用资源时再查询资源是否成功获取 同步阻塞：线程开始请求资源时，暂停后续所有操作，直到资源成功返回 同步非阻塞：线程请求资源后立刻返回，不管资源是否真正获取。核心是欺骗线程资源已获取，它会在使用资源处阻塞 异步：线程请求资源，但不需要返回。当需要使用资源时，若资源未到位，则在此处阻塞 总结 阻塞和非阻塞的区别是资源的 获取 和 返回 是否需要一同完成。换句话说，资\n源请求之后是否需要 立刻使用 。阻塞是必然存在的，因为没有资源就没法执行。重点是充分利用 资源请求 和 资源使用 之间的时间。也因此，异步没有阻塞和非阻塞的说法。\n","date":"2023-08-19","edit":"2022-11-28","permalink":"/series/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5/","section":"series","summary":"说明 同步：必须等到资源返回之后才能继续执行 异步：先请求资源，之后在需要的地方使用资源 阻塞：资源请求后，必须成功获取返回后才能继续执行 非阻塞：","tags":null,"title":"同步、异步、阻塞和非阻塞之间的概念"}]